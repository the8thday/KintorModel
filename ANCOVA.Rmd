---
title: "ANCOVA"
author: "liuc"
date: "2/11/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 协方差分析

此文通过一个小示例记录协方差分析以及计算 emmeans时的应用。 比如在具有主要结局指标的重复测量数据分析中， 以baseline作为协变量，以某一时期的结果作为主要结局变量，则通常会采用协变量的方法进行分析。
协变量分析的效应值就是矫正过的在各个分组中的均值，协方差分析的自变量至少包括一个分类变量和一个数值型变量。

emmenas为在各个分组中outcome的均值；contrasts为不同分组间的差异，汇报的结果一般还需要包括Pvalue和95%CI。


```{r, include=FALSE}
library(tidyverse)
library(easystats)
library(rstatix)
library(grafify)
library(emmeans)
library(marginaleffects)
```


```{r}
df <- readr::read_rds('./datasets/foo3.rds')

# 此数据集中以W24D1作为主要结局指标。
# W1D1作为协变量，可以理解为W1为basline数据
# 研究项目分组 为分类变量。

skimr::skim(df)
```

首先是否满足的分析条件，和一般线性回归一样，需要满足LINE，同时还需要协变量和因变量之间不存在交互效应。
以下分步骤所做的检测，亦可在模型建立后performance::check_model进行（推荐）。

*对于不满足条件的，可以用sm包的非参数检验方法的sm.ancova()函数进行分析。*

```{r}
# raw means
# 可以初步看待下不同分组中的raw means
df %>% select(W1D1, `研究项目分组`, diffW24) %>% distinct() %>% 
  group_by(`研究项目分组`) %>% summarise(mm = mean(diffW24))


# 正态性
df %>% group_by(`研究项目分组`) %>% identify_outliers(diffW24)
df %>% group_by(`研究项目分组`) %>% shapiro_test(diffW24)
df %>% levene_test(diffW24 ~ `研究项目分组`)

# 线性，不同分组
ggpubr::ggscatter(
  df, x = "W1D1", y = "diffW24",
  color = "研究项目分组", add = "reg.line"
)+
  ggpubr::stat_regline_equation(
    aes(label =  paste(..eq.label.., ..rr.label.., sep = "~~~~"), color = `研究项目分组`)
  )

# 因变量和协变量的交互效应, 如果有交互效应应该怎么处理呢
anova_test(data = df,
       formula = diffW24 ~ `研究项目分组`* W1D1
       )

```

当以上条件基本满足后就可以展开协方差分析。作为其实本质是线性分析的方法，其可以纳入的协变量的个数不应该只有一个。。

one-way ANCOVA
构建模型。在R中需要注意*aov函数要求协变量写在效应变量前面*。

```{r}
# 
aov_res <- aov(diffW24 ~ W1D1 + `研究项目分组`, # W1D1为需考虑的协变量
               data = df)

# type III
car::Anova(aov_res, type =  'III')

# 两两post hoc 分析
pwc3 <- emmeans_test(
  diffW24 ~ `研究项目分组`,
  covariate = W1D1,
  p.adjust.method = "bonferroni",
  data = df,
  detailed = TRUE
  )
pwc3 # pairwise comparison p-value, 可以看到其95%CI没有经过矫正
get_emmeans(pwc3)

grafify::posthoc_Levelwise(Model = aov_res,
                           Fixed_Factor = c("研究项目分组"),
                           infer = c(TRUE, TRUE)
                           )
```

emmeans 计算以及分析.
以上所用到的函数emmeans_test和posthoc_Levelwise的结果在95%CI上有些许出入，应该和不同的矫正方法有关。
下面对协方差的emmeans利用emmeans包分步进行。可以看到emmeans_test的结果没有经过P值矫正，而posthoc_Levelwise的
95%CI经过了bonferroni矫正。

```{r}
# 每一个变量及其因子的emmeans
(emm_res <- emmeans::emmeans(aov_res, specs = '研究项目分组'))

# 两两比对的contrast
pairs(emm_res, adjust = 'bonferroni', infer = c(TRUE, TRUE))

contrast(emm_res, method = 'pairwise', adjust = 'none', infer = c(T, T))

plot(emm_res, comparisons = TRUE) + theme_bw() +
  labs(x = "Estimated Marginal Mean")

```

### 和线性模型的对比

将下面的模型和aov_res对比，可以见到二者是一致的。

可以推测到对于简单线性模型`lm(diffW24 ~ `研究项目分组`, data = df)`和直接计算`mean`值得到的结果应该是一致的。

```{r}
# ?aov 本就是利用线性模型得到的分析

lm_fit <- lm(diffW24 ~ W1D1 + `研究项目分组`,
               data = df)

summary(lm_fit)
car::Anova(lm_fit, type = 'III')
```


### 多因素协方差分析

多因素方差分析和多因素协方差分析类同。
在进行post hoc分析时，要依据交互效应是否有统计学意义，进行不同的分析思路。
如果没有交互效应则按照一个分组分别汇报另一个分组的主效应。
如果交互效应有统计学意义，则可以按照dislevel的分组分别对`研究项目分组`进行oneway ANCOVA的分析. 然后Compute pairwise comparisons between treatment groups 


```{r}
aov.res2 <- aov(formula = diffW24 ~ W1D1 + `研究项目分组` * dislevel,
                data = df
                )

performance(aov.res2)

car::Anova(aov.res2, type = 'III')
```

下面进行post-hoc 分析. 考虑没有交互效应。
按照dislevel分组，分别计算`研究项目分组`分组中的emmeans。

```{r}
pc <- emmeans::emmeans(aov.res2,
                       specs = trt.vs.ctrl ~ `研究项目分组`|dislevel,
                       type = "response",
                       ref = 1,
                       adjust = 'fdr', infer = c(TRUE, TRUE))
pc

(emm_res <- emmeans(aov.res2, specs = c("研究项目分组", 'dislevel')))
contrast(emm_res, method = 'trt.vs.ctrl',
         type = 'response', adjust = 'fdr',by = 'dislevel', infer = c(TRUE, TRUE))
```


#### 基于`modelbased`包的分析

`modelbased`包提供包括，也都是对emmeans的包装:

- `estimate_means()`, Estimates the average values at each factor levels
- `estimate_contrasts()`, Estimates and tests contrasts between different factor levels
- `estimate_expectation()`等方便的函数。

```{r}
# model的emmeans
# 每一个变量的factor level的emmeans
# at 参数自动选择
# This is typically used when some of the predictors of interest are factors.
emm = modelbased::estimate_means(model = aov_res, 
                           at = '研究项目分组',
                           transform = 'response',
                           ci = 0.95
                           )
modelbased::estimate_means(model = aov_res, 
                           at = '研究项目分组=c("安慰剂BID", "5mgBID")',
                           transform = 'response',
                           ci = 0.95
                           )
plot(emm)
# standardize(emm)

# contrast
# 可以指定reference contrast(ref)
con <- modelbased::estimate_contrasts(model = aov_res,
                               contrast = "研究项目分组",
                               ci = 0.95,
                               adjust = 'holm', # 怎么此参数没用？一直都是tukey的结果
                               method = 'revpairwise'
                               )
# 二者的结果不一样，是因为上面好像有bug
contrast(emm_res, method = 'revpairwise', adjust = 'holm', infer = c(T, T))

plot(con, emm)


# is not values on the response variable, but the model's parameters
# marginal effects return averages of coefficients
# 在对"研究项目分组"这一分类变量矫正后，W1D1的effect is negative and significant
modelbased::estimate_slopes(model = aov_res)
slopes <- estimate_slopes(aov_res, trend = "W1D1", at = "研究项目分组")

slopes

```


预测值和真实值:

从图中的结果可以看到预测的效果似乎一般。

```{r}
pred_data <- estimate_expectation(aov_res)
head(pred_data)

pred_data$diffW24 <- df$diffW24
pred_data$Predicted_2 <- estimate_expectation(aov.res2)$Predicted

pred_data %>%
  ggplot() +
  geom_line(aes(x = diffW24, y = diffW24), linetype = "dashed") +
  geom_point(aes(x = diffW24, y = Predicted), color = "grey") +
  geom_point(aes(x = diffW24, y = Predicted_2), color = "red") +
  ylab("diffW24 (predicted)") +
  theme_modern()
```

estimate the relationship between the response and the two predictors.

三组用药组的diffW24都随着W1D1的增加有下降的趋势，可以考虑在入组时患者screen期的数据不要太大。

```{r}
predicted <- estimate_expectation(aov_res, data = "grid")

df %>%
  ggplot(aes(x = W1D1)) +
  geom_point(aes(y = diffW24, color = `研究项目分组`)) +
  geom_ribbon(data = predicted, aes(ymin = CI_low, ymax = CI_high, 
                                    fill = `研究项目分组`), alpha = 0.3) +
  geom_line(data = predicted, aes(y = Predicted, color = `研究项目分组`), size = 1) +
  theme_modern()
```



####  将结果输出成所需要的表格并绘制森林图

*森林图*

```{r}
con_p <- pc$contrasts %>% as.data.frame() %>% 
  as_tibble()

plot(pc) + theme_bw()
```

下面利用forestplot包进行绘制，不过此包的使用主要是还是以整理成其所需要的数据格式为主，似乎可操作性差一些。

```{r}
library(forestplot)

ss <- tibble(mean  = 0.531, 
             lower = 0.386,
             upper = 0.731,
             dislevel = "Summary",
             contrast = NA,
             summary = TRUE)

header <- tibble(dislevel = c("Dislevel"),
                 contrast = c("Contrast"),
                 summary = TRUE)

empty_row <- tibble(mean = NA_real_)

con_p <- con_p %>% 
  rename('mean'=estimate,
         'lower' = lower.CL,
         'upper' = upper.CL
         ) %>% select(dislevel, contrast, mean, lower, upper)

header %>% bind_rows(con_p) %>% bind_rows(empty_row) %>% bind_rows(ss) %>% 
  forestplot(
    labeltext = c(dislevel, contrast),
    mean = mean,
    lower = lower,
    upper = upper,
    hrzl_lines = gpar(col = "#444444"),
    is.summary = summary,
    zero = 12,
    grid = structure(c(10), 
                     gp = gpar(lty = 2, col = "#CCCCFF")),
    col = fpColors(box = "royalblue",
                   line = "darkblue",
                   summary = "royalblue"),
    title = 'Forest Plot'
  )
```

forest plot by forester
麻烦的永远是整理森林图的数据。不知能否基于某些模型的输出自动整理待分析的数据。

```{r}
# devtools::install_github("rdboyes/forester")
library(forester)


demo_data <- read_csv('./datasets/forest_data.csv')
demo_data$dislevel <- ifelse(is.na(demo_data$contrast),
                          demo_data$dislevel,
                          paste0("  ", demo_data$dislevel))


forester(left_side_data = demo_data[,1:2],
         estimate = demo_data$mean,
         ci_low = demo_data$lower,
         ci_high = demo_data$upper,
         display = FALSE,
         null_line_at = 10,
         font_family = "sans",
         estimate_col_name = "Estimate (95% CI)",
         file_path = here::here("/Users/congliu/Downloads/forester_plot.png"),
         xlim = c(-10, 50),
         ggplot_width = 20,
         arrows = TRUE,
         arrow_labels = c("kx826 Better", "Placebo Better"),
         )
```


R里面合适的森林图包还是需要一个的呀。

```{r}
library(forestploter)


f <- data.frame(aa)

# Add blank column for the forest plot to display CI.
# Adjust the column width with space. 
# 这里用空白行放在画图部分的前面
f$` ` <- paste(rep(" ", 20), collapse = " ")

# Create confidence interval column to display
f$`Diff (95% CI)` <- ifelse(is.na(f$SE), "",
                             sprintf("%.2f (%.2f to %.2f)",
                                     f$estimate, f$lower.CL, f$upper.CL))

# Define theme
tm <- forest_theme(base_size = 10,
                   refline_col = "red",
                   arrow_type = "closed",
                   footnote_col = "blue")

p <- forest(f[,c(1:2, 10:11)],
            est = f$estimate,
            lower = f$lower.CL, 
            upper = f$upper.CL,
            sizes = f$SE,
            ci_column = 3, # 即是画出来的CI放在第几列，要和空白行连在一起
            ref_line = 0,
            arrow_lab = c("Placebo Better", "Treatment Better"),
            # xlim = c(0, 4),
            # ticks_at = c(0.5, 1, 2, 3),
            footnote = "This is the demo data. Please feel free to change\nanything you want.",
            # theme = tm
            )

# Print plot
plot(p)
```


