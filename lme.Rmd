---
title: "linear mixed effect model"
author: "liuc"
date: "10/28/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## linear mixed effect model

> https://m-clark.github.io/mixed-models-with-R/random_intercepts.html
> https://poissonisfish.com/2017/12/11/linear-mixed-effect-models-in-r/
> https://bbolker.github.io/mixedmodels-misc/


对于医学中常见的纵向数据，同一个受试者在不同时间的因变量值是相关的，不同受试者的因变量值可以认为不独立。线性混合模型用来解释因变量的连续型和分类型自变量的作用称为*固定效应*， 个体之间的差别的影响称为*随机效应*,随机效应是用来代表观察对象间的差异以及观察对象内的差异（如由重复测量造成的相关性），这些差异是随机的且不可观察到的。

混合模型的优点之一就是可以处理不等距时间数据，这对于分析临床回顾性研究中收集的患者不等距时间点上的重复测量数据是非常合适的。

线性混合模型的应用较多，此处只针对医学研究中常见的重复测量数据分析。


```{r, include=FALSE}
library(tidyverse)
library(easystats)
library(lme4)
library(lmerTest)
library(ggeffects)
library(emmeans)

# data(package = 'lme4')
```

## use lmer

> https://ase.tufts.edu/bugs/guide/assets/mixed_model_guide.html

首先是检验数据因变量的概率分布，在这一点上似乎和广义线性模型相似，线性混合模型需要因变量满足正态性.
如果不符合正态性检验，需选择正确的建模方法，比如penalized quasilikelihood (PQL) 、Laplace approximation and Markov chain Monte Carlo algorithms (MCMC).

PQL is a flexible technique that can deal with non-normal data, unbalanced design, and crossed random effects. However, it produces biased estimates if your response variable fits a discrete count distribution, like Poisson or binomial, and the mean is less than 5 - or if your response variable is binary.

The Laplace approximation can handle up to 3 random effects.Any more than that, and you'll have to use MCMC, which is a Bayesian method that can be somewhat confusing.

the Laplace approximation is a special case of a parameter estimation method called Gauss-Hermite quadrature (GHQ), with one iteration. GHQ is more accurate than Laplace due to repeated iterations, but becomes less flexible after the first iteration, so you can only use it for one random effect. 

不过通过performance::check_models似乎更安全 ，不确定此处的正态性检验是对因变量还是残差。   

除此之外，对于outlier等数据的处理，NA值的处理等。

```{r}
df2 <- readRDS('./datasets/df2.rds')

car::qqPlot(df2$score)
car::qqp(log(df2$score))
car::qqp(df2$score, 'lnorm')
# 可以看到数据不是很符合正态分布，但符合正态分布在实际中不是一件简单的事情，差不多就可以。
# 像本次数据的分布有些过于不符合了
```

寻找最佳随机效应结构,找到了模型最好的随机效应结构，接下来我们就给模型加入固定效应。
lme模型的构建在先验知识外，可以展开随机效应结构的筛选。
但怎么判定一个变量是固定效应变量还是随机效应变量呢？有人讲尝试每一个变量作为随机效应，但似乎并不可取。通过对项目本身的知识来选择似乎更靠谱。

REML estimation is unbiased but does not allow for comparing models with different fixed structures. Only use the REML estimation on the optimal model.

所以在进行效应选择的时候，用ML算法。

*随机效应的选择*
```{r}
nullmodel1 <- lme4::lmer(score ~ 1 + (1|PatientID), data = df2, REML=FALSE)
nullmodel2 <- lme4::lmer( score ~ 1 + (1 + class |PatientID), data = df2, REML=FALSE)
nullmodel3 <- lme4::lmer( score ~ 1 + (1 + time |PatientID), data = df2, REML=FALSE)

anova (nullmodel1, nullmodel2) #  基于LRT比的模型间的对比，同时还考虑模型的AIC/BIC/
```

```{r}
test_performance(nullmodel1, nullmodel2)

compare_performance(nullmodel1, nullmodel2) |> plot()
```


上面的结果可以看到，nullmodel1有较好的指标，所以只选择随机intersect即可，不用考虑其他变量的随机slope。

固定效应的纳入，一般结合具体问题和样本量进行取舍。变量的纳入参考10人1⃣️变量。

```{r}
# https://rpubs.com/rslbliss/r_mlm_ws#:~:text=To%20run%20a%20multilevel%20linear,we%20have%20used%20thus%20far.&text=Note%20that%20R%20uses%20restricted%20maximum%20likelihood%20to%20fit%20the%20model.
# same df2 data as in gee.Rmd

# 以入组后的2次测量值为因变量， 以处理效应、时间效应等为固定效应， 以不同病人作为随机效
lme_model <- 
  lmerTest::lmer(score ~ time + class + AGE + (1|`PatientID`),
             data = df2
             )
summary(lme_model)

lme_model2 <- 
  lme4::lmer(score ~ time * class + AGE + (0 + class |`PatientID`),
             data = df2
             )

lme_model3 <- update(lme_model2, .~.-AGE)
# To keep the intercept fixed while keeping the random slope, replace the “1” with a “0”
```

*结果解读：*everything to the left of the | indicates the effects that should be random, and the variable to the right of the | is the grouping variable across which the effects should vary. What is the “1”? It’s the way we refer to the intercept.
lme模型和gee.Rmd中的示例为同一数据，我们在只考虑随机截距的情况下，Fixed effects中Estimate值和gee结果保持一致，说明自变量。random effects为随机效应， Groups列为随机效应因素, 此处只对Intercept的PatientID考虑了随机因素, 通过其Variance的大小可以判断随机截距效应是否应该考虑.
*REML criterion at convergence: *REML(restricted maximum likelihood), 
*Random effects: * The “Residual” standard deviation refers to σ. 如果Variance太小的话，则随机效应可能不太重要。
*Fixed Effects: * 随机效应的解释可以为timeDay1对比于(Intercept)中的timeDay0，score值减少了-147.260。AGE变量的话是可以不用考虑的。


```{r}
sjPlot::tab_model(lme_model,
                  p.val = "kr", # kr 方法计算的p值更为精准
                  show.df = TRUE
                  )

gtsummary::tbl_regression(lme_model,
                          intercept = TRUE
                          )
```


```{r}
VarCorr(lme_model)

# 可重复性
# 如果你得到的重复性小于1.0，那么个体内测量结果之间的变化来源是什么。仅是测量误差吗？
216.0^2/(216.0^2 + 417.9^2)
```


Estimates of Covariance Parameters:
对随机截距进行检验, 简单理解为不同观察者Y指标初始值之间的差异具有显著统计学意义。

```{r}
lmerTest::ranova(lme_model)
```



```{r}
test_performance(lme_model, lme_model2)

compare_performance(lme_model, lme_model2) |> plot()
```

```{r}
check_model(lme_model)
```


Group-level Effects

此处的group为患者，注意患者数目对绘图的影响。

```{r}
random <- estimate_grouplevel(lme_model)
random

plot(random) +
  theme_lucid()
```

```{r}
# type III
car::Anova(lme_model, type = 'III')


# Satterthwaite's method
anova(lme_model)


# to see all 134 models
# coef(lme_model)

plot(ggemmeans(lme_model, terms = c("time", "class"))) + 
  ggplot2::ggtitle("GLMER Effect plot")
```

*结果interpre* 在模型构建完成后，应该如何展示分析的结果呢？typeIII结果可以表明变量对模型的贡献度。
同时还可以汇报emmeans，以及不同分组中的emmeans的差值以及对应的95%CI。

```{r}
# 计算emmeans，以及contrasts
(emm_res <- emmeans(lme_model, specs = c('time', 'class')))

pc <- emmeans::emmeans(lme_model,
                       specs = trt.vs.ctrl ~ time | class,
                       type = "response",
                       ref = 1,
                       adjust = 'fdr', infer = c(TRUE, TRUE))
pc

# 当然还可以 通过如下方式，求得两两比对的结果，结果同pairs(emm_res)
# contrast(emm_res, method='pairwise', by = 'class')
grafify::posthoc_Levelwise(lme_model,
                           c("time", 'class'))
```


```{r}
## Pairwise comparisons, 对于lme模型中emmeans值进行两两比较，自然是针对分类变量
(emm_res <- emmeans(lme_model, specs = 'Time'))
pairs(emm_res)
contrast(emm_res)
plot(emm_res, comparisons = TRUE) + theme_bw() +
  labs(y = "", x = "Estimated marginal mean")
```


```{r}
library(gtsummary)

tbl_data <- df_p_long %>% 
  select(Subject, Folder, !!x_input, ACTARM) %>% 
  distinct() %>% 
  pivot_wider(names_from = Folder, values_from = !!x_input)
  # janitor::clean_names()
  # labelled::remove_labels()


gtsummary::tbl_summary(tbl_data %>% select(-Subject),
                       by = ACTARM,
                       missing = 'no',
                       type = all_continuous() ~ 'continuous2',
                       statistic = list(all_continuous() ~ c("{N_nonmiss}",
                                                             "{mean} ({sd})",
                                                             "{median} ({p25}, {p75})", 
                                                             "{min}, {max}"),
                                        all_categorical() ~ "{n} / {N} ({p}%)")
                       ) %>% 
   modify_header(all_stat_cols() ~ "**{level}**<br>N = {n} ({style_percent(p)}%)") %>%
  add_n() %>% 
  add_p() %>% 
  bold_labels() %>% 
  modify_spanning_header(all_stat_cols() ~ glue::glue("**{x_string}**"))
```


```{r}
gtsummary::tbl_regression(lme_model,
                          intercept = TRUE
                          )
```


*use easystats to get model parameter or effectsize or performance*
下面针对模型的参数和performance进行展示

```{r}
# 首先是是否满足线性混合模型的条件
performance::check_model(lme_model) # 可以看到残差不是很满足正态性分布。

# 其次是模型自身的表现，一般用于模型间的比对
performance::performance(lme_model)

# 相对于summary的结果，多了95%CI,不过通过confint函数也可以计算
parameters::parameters(lme_model)
```


对模型计算effectsize时得到的是Standardization的结果？

```{r}
effectsize::effectsize(lme_model)
```






*use glmer 广义混合模型*

glmer可以用于处理因变量为分类的数据，即是*Multilevel logistic models*，以及种种其他不符合正态分布的因变量数据。

对log转换后的数据进行符合正态分布的线性分析并不是一件值得去做的事情。
The reason we want to use a GLMM for this is that if we imagine a stastical method as E(x), E(ln(x)) is not the same as ln(E(x)). 

```{r}
glme_model <- 
  lme4::glmer(
    score ~ time + class + AGE + (1|`PatientID`),
             data = df2,
             family = 'gaussian'
  )

summary(glme_model) # same as lme_model

# Run logistic model with random intercept and slope
model <- glmer(white ~ homework + (1 + homework | schid), data=mlmdata,
               family=binomial(link="logit"))
summary(model)
```

```{r}

compare_performance(lme_model, glme_model)

plot(compare_performance(lme_model, glme_model))
```



## lme by tidymodels

tidymodels 有提供一系列的统计模型的方法，这是基于R生态的优势之所在。但`tidymodels`一贯的以预测作为模型的主要目的，而在我们的分析中，很多时候模型是作为解释自变量对因变量的影响而展开的。

multilevelmod包支持的模型还是极为广泛的。不过如果只是作为一个模型拟合的过程，似乎没有必要用到tidymodels，毕竟一个模型的拟合所涉及到的各种自变量的问题，是一个需要循环往复的过程，模型的诊断、对比、选择、解释等等才是分析时需要大量考虑的事情。

下面仅在tidymodel的框架下复现一个线性混合模型的应用：

```{r, include=FALSE}

library(tidyverse)
library(tidymodels)
library(multilevelmod)
library(broom.mixed)

tidymodels_prefer()
theme_set(theme_bw())
```


```{r, include=FALSE}
df <- read_csv('~/OneDrive/kintor/Daily_Work/US30001_COVID/lme_data.csv')
```


```{r}
car::qqp(df$LOGCHG, 'norm')

car::qqPlot(df$LOGCHG, 'lnorm')
```


GEE模型
```{r}
gee_spec <- 
  linear_reg() %>% 
  set_engine("gee", corstr = "exchangeable")
```


MME模型
```{r}
lmer_spec <- 
  linear_reg() %>% 
  set_engine("lmer")

lmer_fit <- 
  lmer_spec %>% 
  fit(LOGCHG ~ VISIT + AGEGR1 + SEX + ACTARM + LOGBASE + (1 | SUBJID), data = df)

lmer_fit
```

`parsnip`类一般包含有模型自身的一些信息
```{r}
lmer_fit %>% extract_fit_engine() %>% 
  summary()
```


*上图的分布提醒我们终然log后的数据，其也呈现出非正态分布的倾向，那么对原始数据AVAL直接进行广义混合模型似乎是一件更为合理的事情 ：*

`MASS::glmmPQL`是对`nlme::lme`的封装，继承`lme`类。

```{r}
car::qqp(df$CHG, 'lnorm')

car::qqp(log10(df$CHG), 'norm')
```


```{r}
PQL_m <- MASS::glmmPQL(fixed = CHG ~ VISIT + AGEGR1 + SEX + ACTARM + LOGBASE,
                       random = ~ 1| SUBJID,
                       family = gaussian(link = "log"),
                       data = df
                       )
```

```{r}
GHQ <- lme4::glmer(LOGCHG ~ VISIT + AGEGR1 + SEX + ACTARM + LOGBASE + (1 | SUBJID), 
             data = df,
             family = gaussian(link = "log"), 
             nAGQ = 1
             )  # Set nAGQ to # of desired iterations, =1就是 Laplace approximation
```


one R structure needs to be specified for each fixed effect and one G structure needs to be specified for each random effect.

```{r}
require(MCMCglmm)
```


```{r}
plot(fitted(lme_model), residuals(lme_model), xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, lty = 2)
lines(smooth.spline(fitted(lme_model), residuals(lme_model)))
```









